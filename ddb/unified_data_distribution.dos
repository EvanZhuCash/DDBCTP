// UNIFIED DATA DISTRIBUTION SYSTEM
// Purpose: Distribute market data efficiently to multiple strategies
// Solves many-to-many relationship: N strategies Ã— M data feeds = NÃ—M subscriptions
// Solution: 1 distributor Ã— M feeds + N strategies Ã— 1 distributor = M+N subscriptions

print("ğŸ“¡ UNIFIED DATA DISTRIBUTION SYSTEM - Market Data Distribution Engine")

// =============================================================================
// CLEANUP
// =============================================================================

def cleanupUnifiedSystem() {
    // Unsubscribe from market data sources
    try { unsubscribeTable(tableName="dominantContractStreamY", actionName="distributor_Y") } catch(ex) {}
    try { unsubscribeTable(tableName="dominantContractStreamM", actionName="distributor_M") } catch(ex) {}
    try { unsubscribeTable(tableName="liveMarketData", actionName="distributor_live") } catch(ex) {}
    
    // Drop distribution tables
    try { undef("unifiedMarketData", SHARED) } catch(ex) {}
    try { undef("distributionLog", SHARED) } catch(ex) {}
    
    print("Unified distribution cleanup completed")
}

cleanupUnifiedSystem()

// =============================================================================
// DISTRIBUTION TABLES
// =============================================================================

print("Creating market data distribution tables...")

// Unified market data stream for all strategies
share streamTable(100000:0, `time`symbol`open`high`low`close`volume`source,
                 [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, INT, STRING]) as unifiedMarketData

// Distribution monitoring log
share streamTable(10000:0, `time`source`records_distributed`total_subscribers,
                 [TIMESTAMP, STRING, INT, INT]) as distributionLog

print("Distribution tables created")

// =============================================================================
// STREAM BROADCAST ENGINE - EFFICIENT DISTRIBUTION
// =============================================================================

// Simple distribution without StreamBroadcastEngine (compatibility fix)
def createMarketDataBroadcastEngine() {
    print("ğŸ”§ Setting up unified market data distribution...")
    
    try {
        // Simple direct distribution approach
        print("âœ… Unified market data distribution ready")
        return true
    } catch(ex) {
        print("âŒ Failed to setup distribution: " + ex)
        return false
    }
}

// Enhanced distribution functions using broadcast engine
def distributeYContractData(mutable yDataBatch) {
    if (size(yDataBatch) == 0) return
    
    // Convert Y contract data to unified format
    unifiedData = select datetime as time, symbol, open, high, low, close, volume, 
                        "BACKTEST_Y" as source
                 from yDataBatch
    
    // Insert into unified stream (broadcast engine will distribute automatically)
    unifiedMarketData.append!(unifiedData)
    
    // Log distribution
    logEntry = table([now()] as time,
                    ["BACKTEST_Y"] as source,
                    [size(yDataBatch)] as records_distributed,
                    [4] as total_subscribers)  // 4 strategies
    distributionLog.append!(logEntry)
    
    print("ğŸ“Š Distributed " + string(size(yDataBatch)) + " Y contract records to unified stream")
}

def distributeMContractData(mutable mDataBatch) {
    if (size(mDataBatch) == 0) return
    
    // Convert M contract data to unified format
    unifiedData = select datetime as time, symbol, open, high, low, close, volume,
                        "BACKTEST_M" as source
                 from mDataBatch
    
    // Insert into unified stream (broadcast engine will distribute automatically)
    unifiedMarketData.append!(unifiedData)
    
    // Log distribution
    logEntry = table([now()] as time,
                    ["BACKTEST_M"] as source,
                    [size(mDataBatch)] as records_distributed,
                    [4] as total_subscribers)  // 4 strategies
    distributionLog.append!(logEntry)
    
    print("ğŸ“Š Distributed " + string(size(mDataBatch)) + " M contract records to unified stream")
}

def distributeLiveMarketData(mutable liveDataBatch) {
    if (size(liveDataBatch) == 0) return
    
    // Convert live data to unified format
    unifiedData = select time, symbol, open, high, low, close, volume,
                        "LIVE_FEED" as source
                 from liveDataBatch
    
    // Insert into unified stream (broadcast engine will distribute automatically)
    unifiedMarketData.append!(unifiedData)
    
    // Log distribution
    logEntry = table([now()] as time,
                    ["LIVE_FEED"] as source,
                    [size(liveDataBatch)] as records_distributed,
                    [4] as total_subscribers)
    distributionLog.append!(logEntry)
    
    print("ğŸ“Š Distributed " + string(size(liveDataBatch)) + " live market records to unified stream")
}

// =============================================================================
// INITIAL DATA DISTRIBUTION (Backtest Mode)
// =============================================================================

def distributeBacktestData() {
    print("ğŸ“Š Checking for backtest data sources...")
    
    try {
        // Wait longer for dominant contract streams to be fully created
        maxWaitTime = 10000  // 10 seconds max wait
        waitInterval = 1000  // Check every 1 second
        totalWaited = 0
        
        foundY = false
        foundM = false
        
        // Keep checking until we find the tables or timeout
        do {
            try {
                if (!foundY) {
                    yRecordCount = exec count(*) from dominantContractStreamY
                    if (yRecordCount > 0) {
                        print("âœ… Found dominantContractStreamY with " + string(yRecordCount) + " records")
                        
                        // Distribute ALL Y data, not just top 10000
                        allYData = select * from dominantContractStreamY order by trading_date, datetime
                        distributeYContractData(allYData)
                        
                        // Subscribe for future Y data
                        subscribeTable(tableName="dominantContractStreamY", actionName="distributor_Y",
                                      handler=distributeYContractData, msgAsTable=true)
                        print("âœ… Subscribed to Y contract stream for backtest")
                        foundY = true
                    }
                }
            } catch(ex) {
                // Table not ready yet, continue waiting
            }
            
            try {
                if (!foundM) {
                    mRecordCount = exec count(*) from dominantContractStreamM
                    if (mRecordCount > 0) {
                        print("âœ… Found dominantContractStreamM with " + string(mRecordCount) + " records")
                        
                        // Distribute ALL M data, not just top 10000
                        allMData = select * from dominantContractStreamM order by trading_date, datetime
                        distributeMContractData(allMData)
                        
                        // Subscribe for future M data
                        subscribeTable(tableName="dominantContractStreamM", actionName="distributor_M",
                                      handler=distributeMContractData, msgAsTable=true)
                        print("âœ… Subscribed to M contract stream for backtest")
                        foundM = true
                    }
                }
            } catch(ex) {
                // Table not ready yet, continue waiting
            }
            
            if (foundY and foundM) {
                print("âœ… Successfully connected to both Y and M contract streams")
                return true
            }
            
            if (totalWaited < maxWaitTime) {
                print("â³ Waiting for contract streams... (" + string(totalWaited/1000) + "s)")
                sleep(waitInterval)
                totalWaited += waitInterval
            }
            
        } while (totalWaited < maxWaitTime)
        
        if (foundY or foundM) {
            print("âš ï¸ Partial success: Found " + iif(foundY, "Y", "") + iif(foundM, " M", "") + " streams")
            return true
        } else {
            print("âŒ Timeout: No contract streams found after " + string(maxWaitTime/1000) + " seconds")
            return false
        }
        
    } catch(ex) {
        print("âš ï¸ Backtest data sources not available: " + ex)
        return false
    }
}

// =============================================================================
// LIVE DATA SUBSCRIPTION (Live Trading Mode)
// =============================================================================

def subscribeLiveData() {
    print("ğŸ“¡ Checking for live market data feed...")
    
    try {
        // Check for live market data feed - use try/catch instead of existsTable
        try {
            liveRecordCount = exec count(*) from liveMarketData
            // Subscribe to live market data
            subscribeTable(tableName="liveMarketData", actionName="distributor_live",
                          handler=distributeLiveMarketData, msgAsTable=true)
            print("âœ… Subscribed to live market data feed")
            return true
        } catch(ex) {
            print("âš ï¸ Live market data feed not available")
            return false
        }
        
    } catch(ex) {
        print("âš ï¸ Could not subscribe to live data: " + ex)
        return false
    }
}

// =============================================================================
// AUTO-DETECT MODE AND START DISTRIBUTION
// =============================================================================

print("ğŸ” Auto-detecting data sources...")

// First, create the StreamBroadcastEngine for efficient distribution
distributionReady = createMarketDataBroadcastEngine()

if (distributionReady) {
    print("âœ… Unified distribution ready for multi-strategy data flow")
    
    backtestMode = distributeBacktestData()
    liveMode = subscribeLiveData()
    
    if (backtestMode) {
        print("âœ… BACKTEST MODE: Distributing historical data to unified stream")
    } else if (liveMode) {
        print("âœ… LIVE MODE: Distributing real-time data to unified stream") 
    } else {
        print("âš ï¸ No data sources detected - distribution ready but idle")
    }
} else {
    print("âŒ Distribution failed to initialize")
}

// =============================================================================
// MONITORING AND STATUS
// =============================================================================

def showDistributionStatus() {
    print("\nğŸ“¡ UNIFIED DISTRIBUTION STATUS")
    print("==========================================")
    
    totalRecords = exec count(*) from unifiedMarketData
    print("ğŸ“Š Total distributed records: " + string(totalRecords))
    
    if (totalRecords > 0) {
        sourceBreakdown = select source, count(*) as records from unifiedMarketData group by source
        print("ğŸ“Š Source breakdown:")
        print(sourceBreakdown)
        
        // Show sample of latest data
        print("\nğŸ“ˆ Latest market data sample:")
        latestData = select top 5 * from unifiedMarketData order by time desc
        print(latestData)
    }
    
    if (exec count(*) from distributionLog > 0) {
        print("\nğŸ“ˆ Recent distribution activity:")
        recentActivity = select top 5 * from distributionLog order by time desc
        print(recentActivity)
    }
    
    print("==========================================")
}

showDistributionStatus()

print("\nâœ… UNIFIED DATA DISTRIBUTION ENGINE READY")
print("ğŸ—ï¸ Architecture:")
print("  ğŸ“¡ Input: dominantContractStreamY/M (backtest) OR liveMarketData (live)")
print("  ğŸ“Š Output: unifiedMarketData (unified stream)")
print("  ğŸ¯ Purpose: Centralized data distribution to all strategies")
print("  ğŸ“ˆ Efficiency: N sources â†’ Unified Distribution â†’ M strategies")

print("\nğŸ“‹ Usage:")
print("  ğŸ”„ BACKTEST: Runs with dominant_contract_stream.dos")
print("  ğŸ“¡ LIVE: Runs with live market data feed")
print("  ğŸ“Š STRATEGIES: Subscribe to unifiedMarketData table")

print("\nğŸš€ Unified data distribution operational!")